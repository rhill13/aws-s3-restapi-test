"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWaiter = void 0;
const poller_1 = require("./poller");
const utils_1 = require("./utils");
const waiter_1 = require("./waiter");
const waiterTimeout = async (seconds) => {
    await utils_1.sleep(seconds);
    return { state: waiter_1.WaiterState.TIMEOUT };
};
const abortTimeout = async (abortSignal) => {
    return new Promise((resolve) => {
        abortSignal.onabort = () => resolve({ state: waiter_1.WaiterState.ABORTED });
    });
};
/**
 * Create a waiter promise that only resolves when:
 * 1. Abort controller is signaled
 * 2. Max wait time is reached
 * 3. `acceptorChecks` succeeds, or fails
 * Otherwise, it invokes `acceptorChecks` with exponential-backoff delay.
 *
 * @internal
 */
const createWaiter = async (options, input, acceptorChecks) => {
    const params = {
        ...waiter_1.waiterServiceDefaults,
        ...options,
    };
    utils_1.validateWaiterOptions(params);
    const exitConditions = [poller_1.runPolling(params, input, acceptorChecks)];
    if (options.abortController) {
        exitConditions.push(abortTimeout(options.abortController.signal));
    }
    return Promise.race(exitConditions);
};
exports.createWaiter = createWaiter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlV2FpdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NyZWF0ZVdhaXRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFFQSxxQ0FBc0M7QUFDdEMsbUNBQXVEO0FBQ3ZELHFDQUF5RztBQUV6RyxNQUFNLGFBQWEsR0FBRyxLQUFLLEVBQUUsT0FBZSxFQUF5QixFQUFFO0lBQ3JFLE1BQU0sYUFBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3JCLE9BQU8sRUFBRSxLQUFLLEVBQUUsb0JBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUN4QyxDQUFDLENBQUM7QUFFRixNQUFNLFlBQVksR0FBRyxLQUFLLEVBQUUsV0FBd0IsRUFBeUIsRUFBRTtJQUM3RSxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUU7UUFDN0IsV0FBVyxDQUFDLE9BQU8sR0FBRyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLEVBQUUsb0JBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBQ3RFLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDO0FBRUY7Ozs7Ozs7O0dBUUc7QUFDSSxNQUFNLFlBQVksR0FBRyxLQUFLLEVBQy9CLE9BQThCLEVBQzlCLEtBQVksRUFDWixjQUF1RSxFQUNoRCxFQUFFO0lBQ3pCLE1BQU0sTUFBTSxHQUFHO1FBQ2IsR0FBRyw4QkFBcUI7UUFDeEIsR0FBRyxPQUFPO0tBQ1gsQ0FBQztJQUNGLDZCQUFxQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRTlCLE1BQU0sY0FBYyxHQUFHLENBQUMsbUJBQVUsQ0FBZ0IsTUFBTSxFQUFFLEtBQUssRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO0lBQ2xGLElBQUksT0FBTyxDQUFDLGVBQWUsRUFBRTtRQUMzQixjQUFjLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7S0FDbkU7SUFDRCxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDdEMsQ0FBQyxDQUFDO0FBaEJXLFFBQUEsWUFBWSxnQkFnQnZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWJvcnRTaWduYWwgfSBmcm9tIFwiQGF3cy1zZGsvdHlwZXNcIjtcblxuaW1wb3J0IHsgcnVuUG9sbGluZyB9IGZyb20gXCIuL3BvbGxlclwiO1xuaW1wb3J0IHsgc2xlZXAsIHZhbGlkYXRlV2FpdGVyT3B0aW9ucyB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBTbWl0aHlDbGllbnQsIFdhaXRlck9wdGlvbnMsIFdhaXRlclJlc3VsdCwgd2FpdGVyU2VydmljZURlZmF1bHRzLCBXYWl0ZXJTdGF0ZSB9IGZyb20gXCIuL3dhaXRlclwiO1xuXG5jb25zdCB3YWl0ZXJUaW1lb3V0ID0gYXN5bmMgKHNlY29uZHM6IG51bWJlcik6IFByb21pc2U8V2FpdGVyUmVzdWx0PiA9PiB7XG4gIGF3YWl0IHNsZWVwKHNlY29uZHMpO1xuICByZXR1cm4geyBzdGF0ZTogV2FpdGVyU3RhdGUuVElNRU9VVCB9O1xufTtcblxuY29uc3QgYWJvcnRUaW1lb3V0ID0gYXN5bmMgKGFib3J0U2lnbmFsOiBBYm9ydFNpZ25hbCk6IFByb21pc2U8V2FpdGVyUmVzdWx0PiA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGFib3J0U2lnbmFsLm9uYWJvcnQgPSAoKSA9PiByZXNvbHZlKHsgc3RhdGU6IFdhaXRlclN0YXRlLkFCT1JURUQgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB3YWl0ZXIgcHJvbWlzZSB0aGF0IG9ubHkgcmVzb2x2ZXMgd2hlbjpcbiAqIDEuIEFib3J0IGNvbnRyb2xsZXIgaXMgc2lnbmFsZWRcbiAqIDIuIE1heCB3YWl0IHRpbWUgaXMgcmVhY2hlZFxuICogMy4gYGFjY2VwdG9yQ2hlY2tzYCBzdWNjZWVkcywgb3IgZmFpbHNcbiAqIE90aGVyd2lzZSwgaXQgaW52b2tlcyBgYWNjZXB0b3JDaGVja3NgIHdpdGggZXhwb25lbnRpYWwtYmFja29mZiBkZWxheS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVdhaXRlciA9IGFzeW5jIDxDbGllbnQgZXh0ZW5kcyBTbWl0aHlDbGllbnQsIElucHV0PihcbiAgb3B0aW9uczogV2FpdGVyT3B0aW9uczxDbGllbnQ+LFxuICBpbnB1dDogSW5wdXQsXG4gIGFjY2VwdG9yQ2hlY2tzOiAoY2xpZW50OiBDbGllbnQsIGlucHV0OiBJbnB1dCkgPT4gUHJvbWlzZTxXYWl0ZXJSZXN1bHQ+XG4pOiBQcm9taXNlPFdhaXRlclJlc3VsdD4gPT4ge1xuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgLi4ud2FpdGVyU2VydmljZURlZmF1bHRzLFxuICAgIC4uLm9wdGlvbnMsXG4gIH07XG4gIHZhbGlkYXRlV2FpdGVyT3B0aW9ucyhwYXJhbXMpO1xuXG4gIGNvbnN0IGV4aXRDb25kaXRpb25zID0gW3J1blBvbGxpbmc8Q2xpZW50LCBJbnB1dD4ocGFyYW1zLCBpbnB1dCwgYWNjZXB0b3JDaGVja3MpXTtcbiAgaWYgKG9wdGlvbnMuYWJvcnRDb250cm9sbGVyKSB7XG4gICAgZXhpdENvbmRpdGlvbnMucHVzaChhYm9ydFRpbWVvdXQob3B0aW9ucy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsKSk7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmFjZShleGl0Q29uZGl0aW9ucyk7XG59O1xuIl19